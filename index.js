const isArrayEqualToValue           = (array, value) => array.every(item => item === value);
const isArrayEqual                  = array => array.length > 0 && array.every(item => item === array[0]);
const checkArrayByCriteria          = (array, criteria) => array.some(v => criteria(v));
const arrayIsNotEmpty               = array => Array.isArray(array) && Object.keys(array).length > 0;
const isArraySubset                 = (arrayA, arrayB) => (new Set(arrayB)).size === (new Set(arrayB.concat(arrayA))).size;
const isArray                       = obj => Array.isArray(obj);
const clone                         = array => array.concat([]);
const compareArrays                 = (arrayA, arrayB) => arrayA.length === arrayB.length && (new Set(arrayA.concat(arrayB)).size === arrayA.length);
const convertArrayToObject          = (array, key) => array.reduce((arrayA, arrayB) => ({ ...arrayA, [arrayB[key]]: arrayB }), {});
const convertArrayOfStringsToNumber = array => array.map(x => +x);
const createCumulativeArray         = array => array.reduce((arrayA, arrayB, i) => i === 0 ? [arrayB] : [...arrayA, arrayB + arrayA[i - 1]], 0);
const createArrayInRange            = (min, max) => [...Array(max - min + 1).keys()].map(i => i + min);
const emptyArray                    = array => array = [];
const closetNumberToValue           = (array, number) => array.reduce((prev, curr) => Math.abs(curr - number) < Math.abs(prev - number) ? curr : prev);
const findLongestString             = words => Math.max(...(words.map(el => el.length)));
const findMaxItemInArray            = array => Math.max(...array);
const findMinItemInArray            = array => Math.min(...array);
const flattenArray                  = array => array.reduce((arrayA, arrayB) => Array.isArray(arrayB) ? [...arrayA, ...flattenArray(arrayB)] : [...arrayA, arrayB], []);
const randomArrayInRange            = (min, max, number) => Array.from({ length: number }, () => Math.floor(Math.random() * (max - min + 1)) + min);
const randomItemFromArray           = array => array[(Math.random() * array.length) | 0];
const getAverageOfArray             = array => array.reduce((arrayA, arrayB) => arrayA + arrayB, 0) / array.length;
const getIntersectionOfArray        = (...array) => [...(array.flat().reduce((map, v) => map.set(v, (map.get(v) || 0) + 1), new Map()))].reduce((acc, [v, count]) => void (count === array.length && acc.push(v)) || acc, []);
const getSumOfArray                 = array => array.reduce((arrayA, arrayB) => arrayA + arrayB, 0);
const getUniqueValuesOfArray        = array => array.filter((el, i, array) => array.indexOf(el) === i);
const getUnionOfArrays              = (...array) => [...new Set(array.flat())];
const groupArrayOfObjectsByKey      = (array, key) => array.reduce((acc, item) => ((acc[item[key]] = [...(acc[item[key]] || []), item]), acc), {});
const mergeArrays                   = (arrayA, arrayB) => arrayA.concat(arrayB);
const partitionArrayOnCondition     = (array, criteria) => array.reduce((acc, i) => (acc[criteria(i) ? 0 : 1].push(i), acc), [[], []]);
const removeFalsyValues             = array => array.filter(Boolean);
const shuffleArray                  = array => array.map(a => ({ sort: Math.random(), value: a})).sort((a, b) => a.sort - b.sort).map(a => a.value);
const sortArrayOfNumbers            = array => array.sort((a, b) => a - b);
const splitArrayIntoChunks          = (array, size) => array.reduce((acc, e, i) => (i % size ? acc[acc.length - 1].push(e) : acc.push([e]), acc), []);
const tranposeMatrix                = matrix => matrix.reduce((prev, next) => next.map((item, i) => (prev[i] || []).concat(next[i])), []);
const unzipArrayOfArrays            = array => array.reduce((acc, c) => (c.forEach((v, i) => acc[i].push(v)), acc), Array.from({ length: Math.max(...array.map(a => a.length)) }, (_) => []));
const zipArrayOfArrays              = (...array) => Array.from({ length: Math.max(...array.map(a => a.length)) }, (_, i) => array.map(a => a[i]));
const isPlainObject                 = v => (!!v && typeof v === 'object' && (v.__proto__ === null || v.__proto__ === Object.prototype));
const isObject                      = v => (v !== null && typeof v === 'object');
const isObjectEmpty                 = obj => Reflect.ownKeys(obj).length === 0 && obj.constructor === Object;
const isObjectEqual                 = (...objects) => objects.every(obj => JSON.stringify(obj) === JSON.stringify(objects[0]));
const arrayToObject                 = array => array.reduce((a, c) => ((a[c[0]] = c[1]), a), {});
const ExtractValueFromObject        = (objs, property) => objs.map(obj => obj[property]);
const getValueOfPath                = (path, obj) => path.split('.').reduce((acc ,c) => acc && acc[c], obj);
const invertKeysOfObject            = obj => Object.keys(obj).reduce((res, k) => Object.assign(res, {[obj[k]]: k}), {});
const OmitSubsetPropFromObject      = (obj, keys) => Object.keys(obj).filter(k => !keys.includes(k)).reduce((res, k) => Object.assign(res, {[k]: obj[k]}), {});
const PickSubsetPropFromObject      = (obj, keys) => Object.keys(obj).filter(k => keys.includes(k)).reduce((res, k) => Object.assign(res, {[k]: obj[k]}), {});

module.exports = { zipArrayOfArrays, unzipArrayOfArrays, tranposeMatrix, splitArrayIntoChunks, sortArrayOfNumbers, shuffleArray, removeFalsyValues, partitionArrayOnCondition, mergeArrays, groupArrayOfObjectsByKey, getUnionOfArrays, getUniqueValuesOfArray, getSumOfArray, getIntersectionOfArray, getAverageOfArray, randomItemFromArray, randomArrayInRange, flattenArray, findMinItemInArray, findMaxItemInArray, emptyArray, findLongestString, closetNumberToValue, createArrayInRange, createCumulativeArray, convertArrayOfStringsToNumber, isArrayEqualToValue, isArrayEqual, checkArrayByCriteria, arrayIsNotEmpty, isArraySubset, isArray, clone, compareArrays, convertArrayToObject, PickSubsetPropFromObject, OmitSubsetPropFromObject, invertKeysOfObject, getValueOfPath, ExtractValueFromObject, arrayToObject, isObjectEqual, isObjectEmpty, isObject, isPlainObject };